{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"The OpenMicrofrontends project aims to provide a formal specification for Microfrontends provided by a server. Think of it as OpenAPI for Microfrontends.  <p>The specification includes:</p> <ul> <li>Basic metadata like name, title, description</li> <li>The assets (js, css) and how to load them</li> <li>The schema of the config object that can be provided when starting the Microfrontend</li> <li>The schema of messages the Microfrontend sends and receives (pub/sub)</li> <li>API proxies that are required to access (protected) backends</li> <li>Security hints</li> </ul> <p>OpenMicrofrontends is not a framework, nor is it owned by any company. It is a community effort to provide a way to describe Microfrontends and how to integrate them in a standardized way. All code we provide is free and open source, and will be forever.</p> <p>The specification makes it possible to decouple Microfrontend development from their integration into applications, and to treat Microfrontends exactly like Microservices with only a different formal description.</p> <p></p> <p>Getting Started</p> <p></p>"},{"location":"descriptions/","title":"Descriptions","text":"<p>Here are some detail aspects of OpenMicrofrontend Descriptions.</p>"},{"location":"descriptions/#assets","title":"Assets","text":"<p>The assets section defines:</p> <ul> <li>Where to find the JS and CSS assets </li> <li>How to load them </li> <li>Hints for browser caching</li> <li>Shared modules</li> </ul> <p>Here is a full example:</p> <pre><code>assets:\n  basePath: /public\n  buildManifestPath: /build.yaml\n  js:\n    moduleSystem: ESM\n    initial:\n      - Microfrontend.js\n    importMap:\n      imports:\n        externalModule1: https://ga.jspm.io/npm:externalModule1@1.2.2/index.js\n        externalModule2: https://ga.jspm.io/npm:externalModule2@5.1.8/index.js\n  css:\n    - styles.css\n</code></pre>"},{"location":"descriptions/#asset-names","title":"Asset Names","text":"<p>The asset names in the Description must remain stable between two deployments, i.e., they must not contain a hash.</p> <p>The reason is that in an environment with rolling updates (like Kubernetes), there can be multiple release versions running at the same time.</p> <p>You should consider exposing a Build Manifest to give the Host Application means for cache busting. </p>"},{"location":"descriptions/#asset-paths","title":"Asset Paths","text":"<p>The actual path of an asset is calculated by combining the basePath with the relative path of the asset. The basePath defaults to /.</p> <p>In the example above the initial JS asset would be served at /public/Microfrontend.js.</p> <p>In this example:</p> <pre><code>assets:\n  js:\n    initial:\n      - public/assets/Microfrontend.js\n</code></pre> <p>it would be served at /public/assets/Microfrontend.js.</p>"},{"location":"descriptions/#module-system","title":"Module System","text":"<p>Possible moduleSystem values are:</p> <ul> <li>ESM</li> <li>SystemJS</li> <li>none</li> </ul> <p>Default is none which means the JS assets should just be added as &lt;script&gt; tags.</p> <p>Note</p> <p>There are some limitations when using ESM, explained in detail in the Implementation Hints section.</p>"},{"location":"descriptions/#import-maps-module-sharing","title":"Import Maps (Module Sharing)","text":"<p>If your Microfrontends require external (shared) modules, you can define them in the importMap section. Scoped module specifier maps (scopes) are not supported.</p> <p>Tip</p> <p>importMaps are the recommended way to share modules between Microfrontends and to reduce bundle sizes.   If you use a proprietary solution like Module Federation, there is currently no standardized way to declare that in the Description. But you could always use Annotations.</p> <p>Note</p> <p>There are some limitations when using ESM, explained in detail in the Implementation Hints section.</p>"},{"location":"descriptions/#build-manifest-browser-caching","title":"Build Manifest (Browser Caching)","text":"<p>Since the asset names are stable, the Host Application needs some means to make sure the Browser loads new assets after a deployment.</p> <p>This is where the Build Manifest comes into play. The Build Manifest is a JSON file served by the Microfrontend Server which contains either  a version or a timestamp property that can be used for cache busting, e.g., by adding it as a query parameter to every asset (?.v=1.0.0). </p> <p>The simplest approach is to use package.json as Build Manifest.</p> <p>The buildManifestPath property is the absolute path to the Build Manifest JSON file.</p>"},{"location":"descriptions/#rendererfunctionname","title":"rendererFunctionName","text":"<p>The Renderer is the function that needs to be called to start the Microfrontend in the Host Frontend. </p> <p>The rendererFunctionName property is the name of a function which is either</p> <ul> <li>A global variable (window object)</li> <li>A named export of one of the initial modules (if modulesSystem is ESM or SystemJS)</li> <li>A property of the default export of one of the initial modules (if modulesSystem is ESM or SystemJS)</li> </ul> <p>The Renderer needs to satisfy the signature defined here . Typically, a generator (such as OpenMicrofrontends Generator) is used to create a tailored and type-safe signature.</p>"},{"location":"descriptions/#security-schemes","title":"Security Schemes","text":"<p>Some routes (paths) on the Microfrontend Server might have security requirements.</p> <p>You can describe security requirements with the top-level securitySchemes section and then apply it to the route as security requirements.</p> <p>Both concepts have been adopted from OpenAPI and are described in detail here:</p> <ul> <li>SecurityScheme Object</li> <li>SecurityRequirement Object</li> </ul> <p>Example:</p> <pre><code>securitySchemes:\n  BasicAuth:\n    type: http\n    scheme: basic\n  BearerAuth:\n    type: http\n    scheme: bearer\n  ApiKeyAuth:\n    type: apiKey\n    in: header\n    name: X-API-Key\n  OpenID:\n    type: openIdConnect\n    openIdConnectUrl: https://example.com/.well-known/openid-configuration\nmicrofrontends:\n- name: My Microfrontend\n  apiProxies:\n    bff:\n      path: /api\n      security:\n      - ApiKeyAuth: []\n  ssr:\n    path: /ssr\n    security:\n    - ApiKeyAuth: []\n</code></pre>"},{"location":"descriptions/#user-permissions","title":"User Permissions","text":"<p>If the Microfrontend has some functionality that depends on the user and his permissions, this can be described in the userPermissions section.</p> <p>Example:</p> <pre><code>userPermissions:\n  permissions:\n    - name: showDetails\n      description: The authenticated user is permitted to see details\n    - name: deletePermitted\n      description: The authenticated user is permitted to delete items\n  provided:\n    path: /permissions\n    security:\n      - ApiKeyAuth: []\n</code></pre> <p>The actual permissions need to determined at runtime, either:</p> <ol> <li>By a Microfrontend Server route, like in the example above via provided</li> <li>By the Host Application</li> </ol> <p>Which option you use depends on the system architecture:</p> <ul> <li>If your Microfrontend is exposed to third parties and comes with a separate security context the first one is the best choice</li> <li>If your Microfrontend is used internally as part of a larger frontend application, it makes sense that the Host Application determines the permissions, e.g., role-based</li> <li>If your Microfrontend doesn't need to know anything about security and just needs to forward access tokens, the second option also is the better choice.     In this case, the Microfrontend could be used in completely different environments and security contexts.</li> </ul> <p>If you define a route that determines the user permissions, it must return a JSON object like this for a GET request:</p> <pre><code>{\n  \"showDetails\": true,\n  \"deletePermitted\": false\n}\n</code></pre> <p>Important</p> <p>User Permission cannot be use to actually protect something because they can easily be changed in the browser.  Their purpose is only to control UI behavior.</p>"},{"location":"descriptions/#api-proxies","title":"API Proxies","text":"<p>The Microfrontend can request API (backend) proxies from the Host Application. A proxy is typically required when:</p> <ul> <li>The API is not publicly available</li> <li>The endpoint requires security measures the frontend cannot provide</li> <li>CORS problems want to be avoided</li> </ul> <p>Example:</p> <p><pre><code>apiProxies:\n  proxy1:\n    description: Proxy for the internal BFF API\n    path: /api\n    security:\n      - ApiKeyAuth: []\n  proxy2:\n    description: A proxy for an external API\n    targets:\n      - url: https://localhost:1234/api\n        description: Local\n      - url: http://my-api.my-namespace:1234/api\n        description: Test environment\n</code></pre> The target of the proxy can either be the Microfrontend Server (BFF) or an external API.</p>"},{"location":"descriptions/#bff","title":"BFF","text":"<p>To proxy the Backend-for-Frontend (BFF) of your Microfrontend, you only have to define the absolute base path.</p>"},{"location":"descriptions/#external-api","title":"External API","text":"<p>For External APIs you can provide a list of possible targets. The actual target for the current environment needs to be determined  by the Host Application. And it can be one not listed in the Description.</p>"},{"location":"descriptions/#usage-in-the-microfrontend","title":"Usage in the Microfrontend","text":"<p>The Host Application will pass an object with the relative proxy paths to the Renderer:</p> <pre><code>const renderer: MyMicrofrontendRenderer = async (host, context) =&gt; {\n    const {config, apiProxyPaths, permissions} = context;\n\n    // The relative path in *apiProxyPaths.bff* will forward the call to &lt;microfrontend-server&gt;/api\n    const response = await fetch(`${apiProxyPaths.bff}/customers/${config.customerId}`);\n\n}\n</code></pre>"},{"location":"descriptions/#server-side-rendering","title":"Server-Side Rendering","text":"<p>If your Microfrontend supports Hybrid Rendering (SSR + Hydration) you can tell the Host Application where to get the pre-rendered HTML from.</p> <p>Example: </p> <pre><code>ssr:\n  path: /ssr\n  security:\n    - ApiKeyAuth: []\n</code></pre> <p>The Host Application can then:</p> <ol> <li>POST the context and config to the route (ssr.path) </li> <li>Add the returned HTML as innerHTML to the Microfrontend container</li> <li>Start the Microfrontend with the flag serverSideRendered set to true</li> </ol>"},{"location":"descriptions/#server-side-renderer","title":"Server-Side Renderer","text":"<p>The Server-Side Renderer needs to satisfy the signature defined here . Typically, a generator (such as OpenMicrofrontends Generator) is used to create a tailored and type-safe signature.</p> <p>The Server-Side Renderer takes the POST body as input, and its result needs to be returned as the response.</p>"},{"location":"descriptions/#usage-in-the-microfrontend_1","title":"Usage in the Microfrontend","text":"<p>The serverSideRendered flag is passed to the Renderer:</p> <pre><code>const renderer: MyMicrofrontendRenderer = async (host, context) =&gt; {\n    const {config, serverSideRendered} = context;\n\n    if (serverSideRendered) {\n        // Hydrate\n    } else {\n        // Client-side Rendering\n    }\n}\n</code></pre>"},{"location":"descriptions/#config","title":"Config","text":"<p>The config section can be used to define an arbitrary configuration object that needs to be passed to the Renderer. It can be used to change the behavior of the Microfrontend or to pass some content IDs.</p> <p>Example:</p> <pre><code>config:\n  schema:\n    type: object\n    properties:\n      customerId:\n        type: string\n    required:\n      - customerId\n    additionalProperties: false\n  default:\n    customerId: '1000'\n</code></pre> <p>The default config must be provided, and it must validate against the schema.</p> <p>Tip</p> <p>schema needs to be a valid JSON schema and the type has to be object.</p> <p>Note</p> <p>A valid default config is required because this allows Host Applications and tools to preview Microfrontends.</p>"},{"location":"descriptions/#usage-in-the-microfrontend_2","title":"Usage in the Microfrontend","text":"<pre><code>const renderer: MyMicrofrontendRenderer = async (host, context) =&gt; {\n    const {config} = context;\n\n    // type: string\n    const customerId = config.customerId;\n}\n</code></pre>"},{"location":"descriptions/#messages","title":"Messages","text":"<p>The messages section can be used to define a list of messages the Microfrontend publishes and/or subscribes to.</p> <p>This allows an exchange of messages between Microfrontends in a type-safe way. </p> <p>Example: </p> <pre><code>messages:\n  ping:\n    publish: true\n    subscribe: true\n    schema:     \n      type: object\n      properties:\n        ping:\n          const: true\n      required:\n        - ping\n</code></pre> <p>This describes an exchange of messages via topic ping and a message body that looks like this:</p> <pre><code>{\n  \"ping\": true\n}\n</code></pre> <p>Tip</p> <p>schema needs to be a valid JSON schema and the type has to be object.</p>"},{"location":"descriptions/#exchange-messages-between-microfrontends","title":"Exchange Messages between Microfrontends","text":"<p>To make sure different Microfrontends use compatible messages, it makes sense to provide the content schemas as external JSON files and reference them:</p> <pre><code>{\n  \"$id\": \"https://my-company.com/messages/ping\",\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"ping\": {\n      \"const\": true\n    }\n  },\n  \"additionalProperties\": false\n}\n</code></pre> <pre><code>messages:\n  ping:\n    publish: true\n    subscribe: true\n    schema:\n      $ref: './pingMessage.json'\n</code></pre>"},{"location":"descriptions/#usage-in-the-microfrontend_3","title":"Usage in the Microfrontend","text":"<p>In the Renderer you will get a messageBus object with type-safe publish and subscribe methods:</p> <pre><code>const renderer: MyMicrofrontendRenderer = async (host, context) =&gt; {\n    const {config, messageBus} = context;\n\n    messageBus.publish('ping', {\n        ping: true\n    });\n    // @ts-expect-error\n    message.publish('someOtherTopic', {});\n}\n</code></pre>"},{"location":"descriptions/#usage-in-the-host-frontend","title":"Usage in the Host Frontend","text":"<p>The Host Application must provide a global Message Bus with generic publish and subscribe implementations. </p> <p>The Starter returns a messages object with type-safe methods for the opposite direction (so, everything published by the Microfrontend can be subscribed to and the other way round).</p> <pre><code>const {close, messages} = await startMyMicrofrontend('http://my-microfrontend.my-namespace:7810', hostElement, {\n    id: '1',\n    config: {\n    },\n    messageBus: globalMessageBus,\n});\n\nmessages.subscribe('ping', (message) =&gt; {\n    console.log(message);\n});\n\n// @ts-expect-error\nmessage.subscribe('someOtherTopic', {});\n</code></pre>"},{"location":"descriptions/#annotations","title":"Annotations","text":"<p>The annotations section can be used to add arbitrary meta-data and information for Host Applications.</p> <p>It could, for example, be used to:</p> <ul> <li>Provide meta-data for dynamic Cockpits that allows automatic discovery of suitable Microfrontends for a specific context </li> <li>Provide some integration hints, like preferred width </li> <li>Provide security hints, like how to determine the user permissions in specific environments</li> <li>State some extra requirements</li> </ul>"},{"location":"descriptions/#validation","title":"Validation","text":"<p>You can use the JSON schema to validate your Description:</p> <pre><code>```yaml\n$schema: 'https://open-microfrontends.org/schemas/1-0-0.json'\nopenMicrofrontends: 1.0.0\n</code></pre> <p>Or use the OpenMicrofrontends Generator, which also performs semantic checks:</p> <pre><code>omg microfrontends.yaml --validationOnly\n</code></pre> <p></p> <p>Example Descriptions</p> <p></p>"},{"location":"generator/","title":"OpenMicrofrontends Generator","text":"<p>The OpenMicrofrontends Generator (OMG) is a tool to generate interfaces  and integration code for an OpenMicrofrontends Description.</p>"},{"location":"generator/#basic-usage","title":"Basic Usage","text":"<p>Add to your package.json:</p> <pre><code>{\n  \"devDependencies\": {\n    \"@open-microfrontends/types\": \"^1.0.0\",\n    \"@open-microfrontends/generator\": \"^1.0.0\"\n  }\n}\n</code></pre> <p>To generate code run:</p> <pre><code>omg &lt;descriptionFile&gt; &lt;outFolder&gt; -t &lt;template1&gt;,&lt;template2&gt;\n</code></pre> <p>Arguments:</p> <ul> <li>descriptionFile: The OpenMicrofrontends description (yaml/json)</li> <li>outFolder: The target folder for generated code (not required for --validationOnly)</li> </ul> <p>Options:</p> Option Description -t, --templates A comma separated list of templates to use -a, --additionalProperties A comma separated list of extra properties to pass to the templates -v, --validationOnly Only validate given spec file and exit --help Usage info"},{"location":"generator/#examples","title":"Examples","text":"<p>Validate your Description:</p> <pre><code>omg microfrontends.yaml --validationOnly\n</code></pre> <p>Generate Renderers:</p> <pre><code>omg microfrontends.yaml src/_generated -t renderers\n</code></pre> <p>Generate Starters:</p> <pre><code>omg microfrontends.yaml src/_generated -t starters\n</code></pre> <p>Generate Host Backend Integrations for a Node.js based server:</p> <pre><code>omg microfrontends.yaml src/_generated -t hostBackendIntegrationsNodeJs\n</code></pre> <p>Generate Host Backend Integrations for a Java based server:</p> <pre><code>omg microfrontends.yaml src/main/org/example/_generated -t hostBackendIntegrationsJavaServlet -a packageName=org.example._generated\n</code></pre> <p></p> <p>OMG Documentation</p> <p></p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>The first step is to create a Description of your new (or existing) Microfrontend. The Description acts as a contract between the Host Application and the Microfrontends Server. A definition can be written as YAML or JSON and can contain multiple Microfrontends.</p> <p>Things you have to take into consideration for the Description:</p> <ul> <li>What are my initial assets and which module system do/will I use?</li> <li>Does my Microfrontend require proxying of APIs and assets (because it is not publicly accessible or the APIs require security)</li> <li>Does my Microfrontend require a configuration at startup?</li> <li>Will my Microfrontend send or receive messages from other Microfrontends on a page?</li> <li>Does my Microfrontend has functionality that depend on the users permissions?</li> <li>Does/should my Microfrontend provide Server-Side Rendering (SSR)?</li> </ul>"},{"location":"getting-started/#description-example","title":"Description Example","text":"<pre><code>$schema: 'https://open-microfrontends.org/schemas/1-0-0.json'\nopenMicrofrontends: 1.0.0\nservers:\n- url: 'http://localhost:7890'\n  description: Local Test Server\nmicrofrontends:\n- name: My First Microfrontend\n  assets:\n    basePath: /public\n    js:\n      moduleSystem: ESM\n      initial:\n        - Microfrontend.js\n  rendererFunctionName: startMyFirstMicrofrontend\n  config:\n    schema:\n      type: object\n      properties:\n        welcomeMessage:\n          type: string\n      required: [\"welcomeMessage\"]\n    default:\n      welcomeMessage: Hello World!\n  messages:\n    ping:\n      publish: true\n      subscribe: true\n      schema:\n        type: object\n        properties:\n          ping:\n            const: true\n        required: [\"ping\"]\n</code></pre> <p>The next step is to generate type-safe code from the Description. You can use the OpenMicrofrontends Generator or any other OpenMicrofrontends generator.</p> <p>The following needs to be generated:</p> <ul> <li>A Renderer interface on the Microfrontend side</li> <li>A Starter and (if necessary) Host Backend Integrations on the Host Application</li> </ul>"},{"location":"getting-started/#renderer","title":"Renderer","text":"<p>Here is an example Renderer implementation based on an interface generated by OpenMicrofrontends Generator:</p> <pre><code>import {\n    MyFirstMicrofrontendRenderer, \n    MyFirstMicrofrontendRendererFunctionName,\n} from './_generated/microfrontendsRenderers';\n\nconst renderer: MyFirstMicrofrontendRenderer = async (host, context) =&gt; {\n  const {config, messageBus} = context;\n  host.innerHTML = `\n    &lt;div&gt;\n      &lt;h2&gt;${config.welcomeMessage}&lt;/h2&gt;\n    &lt;/div&gt;\n  `;\n  const onPing = () =&gt; { /* do something */ };\n  // Type safe!\n  messageBus.subscribe('ping', onPing);\n  return {\n    onRemove: () =&gt; {\n      host.innerHTML = '';\n      messageBus.unsubscribe('ping', onPing);\n    }\n  }\n}\n\n// If you bundle your code to ESM oder SystemJS\nexport default {\n  [MyFirstMicrofrontendRendererFunctionName]: renderFn,\n};\n// Or otherwise (this always works)\n// window[MyFirstMicrofrontendRendererFunctionName] = renderFn;\n</code></pre> <p>All you need now is to put the code above into your index file, bundle it and add a server that provides it at /public/Microfrontend.js (because the basePath is /public).</p>"},{"location":"getting-started/#starter","title":"Starter","text":"<p>On the Host Application side, you can start the Microfrontend like this with a Starter generated by OpenMicrofrontends Generator:</p> <pre><code>import {startMyFirstMicrofrontend} from './_generated/microfrontendStarters';\n\nconst hostElement = document.getElementById('root');\n\nconst {close, messages} = await startMyFirstMicrofrontend(\n    'https://my-microfrontend-server.com', hostElement, {\n        id: '1',\n        // lang: 'en',\n        // user,\n        config: {\n            welcomeMessage: 'Microfrontend Demo!',\n        },\n        messageBus: globalMessageBus, \n    });\n\n\n// Send a message to the Microfrontend - type-safe!\nmessages.publish('ping', { ping: true });\n</code></pre>"},{"location":"getting-started/#host-backend-integration","title":"Host Backend Integration","text":"<p>The example Description above does not contain any definitions that require a Host Backend Integration. Here is a more complex example with API proxies, security and User Permissions:</p> <pre><code>$schema: 'https://open-microfrontends.org/schemas/1-0-0.json'\nopenMicrofrontends: 1.0.0\nservers:\n- url: 'http://localhost:8080'\n  description: Local Test Server\nsecuritySchemes:\n  ApiKeyAuth:\n    type: apiKey\n    in: header\n    name: X-API-KEY\nmicrofrontends:\n- name: My Second Microfrontend\n  assets:\n    buildManifestPath: /package.json\n    js:\n      moduleSystem: SystemJS\n      initial:\n      - Microfrontend.js\n  rendererFunctionName: startMySecondMicrofrontend\n  userPermissions:\n    provided:\n      path: /permissions\n      security:\n      - ApiKeyAuth: [ ]\n    permissions:\n      - name: deleteCustomer\n        description: The user has the permission to delete a customer\n  apiProxies:\n    bff:\n      path: /api\n      security:\n      - ApiKeyAuth: [ ]\n    someExternalApi:\n      targets:\n      - url: \"http://my-service.my-dev-namespace.svc.cluster.local:8080\"\n        description: My Service DEV\n  config:\n    schema:\n      type: object\n      properties:\n        customerId:\n          type: string\n          description: The customer ID\n      required:\n        - customerId\n    default:\n      customerId: '1000'\n</code></pre> <p>OpenMicrofrontends Generator can generate the necessary Host Backend Integration code, which can be used like below (here, for example, with Express).</p> <p>First, define the config:</p> <pre><code>import {MySecondMicrofrontendBaseSetup} from './_generated/microfrontendHostIntegrations';\n\nexport default class MySecondMicrofrontendBaseSetupImpl implements MySecondMicrofrontendBaseSetup {\n  get microfrontendBaseUrl() {\n    return 'http://second-microfrontend.my-test-namespace.svc.cluster.local:8080';\n  };\n\n  async getUser(req: IncomingMessage)  {\n    // TODO\n    return null;\n  }\n\n  async apiProxyRequestBffGetSecurityHeaders(req: IncomingMessage): Promise&lt;Record&lt;string, string&gt;&gt; {\n    return {\n        'x-api-key': '123456',\n    };\n  }\n\n  get apiProxySomeExternalApiUrl() {\n    return 'http://my-service.my-test-namespace.svc.cluster.local:8080';\n  };\n\n  async userPermissionsRequestGetSecurityHeaders(req: IncomingMessage): Promise&lt;Record&lt;string, string&gt;&gt; {\n    return {\n        'x-api-key': '123456',\n    };\n  }\n}\n</code></pre> <p>Then, add the generated middleware:</p> <pre><code>import {mySecondMicrofrontendHostIntegrationMiddleware} from './_generated/microfrontendHostIntegrations';\n\nconst app = express();\n\n// ...\n\napp.use(mySecondMicrofrontendHostIntegrationMiddleware(\n  new MySecondMicrofrontendBaseSetupImpl()\n));\n</code></pre> <p>In the Microfrontend the proxies and the User Permissions can be used like this:</p> <pre><code>const renderer: MySecondMicrofrontendRenderer = async (host, context) =&gt; {\n    const {config, apiProxyPaths, permissions} = context;\n\n    // type: boolean\n    const userHasPermissionToDeleteCustomer = permissions.deleteCustomer;\n\n    // Load customer (via proxy)\n    const response = await fetch(`${apiProxyPaths.bff}/customers/${config.customerId}`);\n\n}\n</code></pre> <p>The Starter changes a bit: You don't have to pass the URL anymore and can no longer set user or permissions:</p> <pre><code>const {close, messages} = await startMyFirstMicrofrontend(\n    hostElement, {\n        id: '1',\n        config: {\n            welcomeMessage: 'Microfrontend Demo!',\n        },\n        messageBus: globalMessageBus, \n    });\n</code></pre> <p></p> <p>OpenMicrofrontend Generator Documentation</p> <p></p> <p>Example Microfrontends and Host Integrations</p> <p></p>"},{"location":"spec-schema/","title":"Specification and JSON Schema","text":""},{"location":"spec-schema/#100","title":"1.0.0","text":"<ul> <li>Specification</li> <li>JSON Schema</li> </ul>"},{"location":"terminology/","title":"Terminology","text":"<p>Here is an overview of the terminology and component names used in the specification and in the documentation of this project.</p> <p>Components for a complete setup with Host Backend integration:</p> <p></p> <p>And here for a simplified, Browser Standalone, setup:</p> <p></p> <p>Note</p> <p>With the simplified setup, all components (Microfrontend Server, APIs, ...) must be publicly accessible and CORS must be enabled. Furthermore, some API security requirements (e.g., BASIC), user permissions and server-side rendering are not available.</p> <ul> <li>Microfrontend: A Microfrontend is a JavaScript frontend bundled into JS and CSS files.</li> <li>Microfrontend Server: A Microfrontend Server serves the Microfrontend assets according to the OpenMicrofrontend Description. Additionally, it should expose the OpenMicrofrontend Description itself, so Host Backend can dynamically register Microfrontends and react to changes.</li> <li>Host Backend: The backend part of the Host Application, which can be used to provide security, proxying of Backend APIs and Server-Side Rendering (SSR).</li> <li>Host Frontend: The frontend part of the Host Application, which is used to start Microfrontends and provide means to interact with them.</li> <li>Backend API: The API a Microfrontend uses to fetch data or perform actions. This can be a REST API, GraphQL, or any other type of API that the Microfrontend needs to function correctly.</li> </ul> <p>Note</p> <p>You can find a more detailed description of the components and the terminology in the Spec.</p>"},{"location":"implementation-hints/","title":"Implementation Hints","text":"<ul> <li>Here you can find some useful hints about some specific aspects in the Microfrontend development</li> <li>And here some Host Application integration hints</li> </ul>"},{"location":"implementation-hints/host-applications/","title":"Host Applications Integration Hints","text":""},{"location":"implementation-hints/host-applications/#host-backend-integration","title":"Host Backend Integration","text":"<p>The first question regarding the integration of a OpenMicrofrontends compliant Microfrontend should be: Is a Host Backend integration required.</p> <p>In doubt, the answer should be yes, because it has a lot of advantages: </p> <ul> <li>The actual Microfrontends are hidden behind the Host Application</li> <li>No CORS problems</li> <li>Proper browser cache busting based on the release version or timestamp</li> </ul> <p>A Host Backend is definitely necessary if:</p> <ul> <li>The Microfrontend is not publicly available </li> <li>The Microfrontend requests API proxies</li> <li>You want to use Server-Side Rendering</li> </ul>"},{"location":"implementation-hints/host-applications/#using-openmicrofrontends-generator","title":"Using OpenMicrofrontends Generator","text":"<p>The following assumes you are using the OpenMicrofrontends Generator to generate the Starter and Host Backend Integrations.</p>"},{"location":"implementation-hints/host-applications/#host-backend-integration_1","title":"Host Backend Integration","text":"<p>The Host Backend integration depends on the programming language and the server framework but usually includes two steps:</p> <ol> <li>Implementing a setup object that defines URLs, security and caching</li> <li>Adding some middleware or filter </li> </ol> <p>Here as example with an Express backend and the hostBackendIntegrationsNodeJs template:</p> <pre><code>import {MyMicrofrontendBaseSetup} from './_generated/microfrontendHostIntegrations';\n\nexport default class MyMicrofrontendBaseSetupImpl implements MyMicrofrontendBaseSetup {\n  get microfrontendBaseUrl() {\n    return 'http://my-microfrontend.my-test-namespace.svc.cluster.local:8080';\n  };\n\n  // Security, Caching, ...\n}\n</code></pre> <pre><code>import {myMicrofrontendHostIntegrationMiddleware} from './_generated/microfrontendHostIntegrations';\n\nconst app = express();\n\n// ...\n\napp.use(myMicrofrontendHostIntegrationMiddleware(\n  new MyMicrofrontendBaseSetupImpl()\n));\n</code></pre>"},{"location":"implementation-hints/host-applications/#starting-the-microfrontend","title":"Starting the Microfrontend","text":"<p>For the frontend-side you need to </p> <ul> <li>generate a Starter </li> <li>provide some MessageBus implementation</li> <li>optionally, the SystemJS loader (see below)</li> </ul> <p>Example:</p> <pre><code>&lt;div id=\"root\"&gt;\n    &lt;!-- Here the Microfrontend will appear --&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>import {startMyMicrofrontend} from './_generated/microfrontendStarters';\n\nconst hostElement = document.getElementById('root');\n\nconst {close, messages} = await startMyMicrofrontend(hostElement, {\n        id: '1',\n        config: {\n            welcomeMessage: 'Microfrontend Demo!',\n        },\n        messageBus: globalMessageBus, \n    });\n\n// Send a message to the Microfrontend - type-safe!\nmessages.publish('ping', { ping: true });\n</code></pre>"},{"location":"implementation-hints/host-applications/#server-side-rendering","title":"Server-Side Rendering","text":"<p>Currently, SSR is only supported by the hostBackendIntegrationsNodeJs template. </p> <p>It works like this:</p> <ul> <li>In your server-side route you fetch the SSR data (HTML + optional script) and</li> <li>Add it to your HTML template</li> </ul> <p>Here, for example, with Express:</p> <pre><code>import {myMicrofrontendServerSideRenderer} from './_generated/microfrontendHostIntegrations';\n\napp.get('index', async (req, res) =&gt; {\n    try {\n        const {contentHtml, headHtml} = await myMicrofrontendServerSideRenderer(req, {\n            id: '1',\n            config: {\n                welcomeMessage: 'Microfrontend Demo!',\n            },\n        });\n        return res.render('index', {\n            microfrontend1ContentHtml: contentHtml,\n            microfrontend1HeadHtml: headHtml,\n        });\n    } catch (e) {\n        // TODO\n    }\n});\n</code></pre> <p>And in the index template:</p> <pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;%-microfrontend1HeadHtml%&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Microfrontend Host Application&lt;/h1&gt;\n        &lt;!-- Important: There should be no whitespace between the div and pre-rendered content --&gt;\n        &lt;div id=\"root\"&gt;&lt;%-microfrontend1ContentHtml%&gt;&lt;/div&gt;\n        &lt;!-- Script that starts the Microfrontend --&gt;\n        &lt;script src=\"main.js\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Important</p> <p>The id passed to the SSR Renderer must be the same as the one used when starting the Microfrontend one the frontend side.</p>"},{"location":"implementation-hints/host-applications/#systemjs","title":"SystemJS","text":"<p>If the Microfrontend uses the moduleSystem SystemJS you have to make sure that SystemJS loader is available in the frontend bevor starting it.</p>"},{"location":"implementation-hints/host-applications/#host-backend-setup","title":"Host Backend Setup","text":"<p>All examples below are based on the hostBackendIntegrationsNodeJs template. But they look very similar for other languages.</p>"},{"location":"implementation-hints/host-applications/#internationalization","title":"Internationalization","text":"<p>Optionally, you can set the language for the current user.</p> <p><pre><code>export default class MyMicrofrontendBaseSetupImpl implements MyMicrofrontendBaseSetup {\n\n    async getLang(req: IncomingMessage) {\n        // Determine the user language\n        return 'en';\n    }   \n}\n</code></pre> You could also pass it to the Starter in the frontend.</p>"},{"location":"implementation-hints/host-applications/#user","title":"User","text":"<p>Optionally, you can set the current user (e.g., the Microfrontend needs to show the users name).</p> <pre><code>export default class MyMicrofrontendBaseSetupImpl implements MyMicrofrontendBaseSetup {\n\n    async getUser(req: IncomingMessage) {\n        // Determine the user \n        return {\n            username: 'testUser',\n            displayName: 'Test User',\n        };\n    }   \n}\n</code></pre>"},{"location":"implementation-hints/host-applications/#user-permissions","title":"User Permissions","text":"<p>If the Microfrontend requires User Permissions but does not provide a route to determine it, the Host Application has to provide them: </p> <pre><code>export default class MyMicrofrontendBaseSetupImpl implements MyMicrofrontendBaseSetup {\n\n    async userPermissionsCalculate(req: IncomingMessage) {\n        // Calculate the permissions from scopes or user roles \n        return {\n            deleteCustomer: true,\n        };\n    }   \n}\n</code></pre>"},{"location":"implementation-hints/host-applications/#api-proxies","title":"API Proxies","text":"<p>If the Microfrontend requests proxies for external APIs, you have to define the actual target URL:</p> <pre><code>export default class MyMicrofrontendBaseSetupImpl implements MyMicrofrontendBaseSetup {\n\n    get apiProxyCustomerApiUrl() {\n        return process.env.CUSTOMER_API_URL;\n    };\n}\n</code></pre>"},{"location":"implementation-hints/host-applications/#timeouts","title":"Timeouts","text":"<p>You can change the timeouts for requests to the Microfrontend Server:</p> <pre><code>export default class MyMicrofrontendBaseSetupImpl implements MyMicrofrontendBaseSetup {\n\n    // Default (e.g., for assets)\n    get microfrontendRequestTimeoutSec() {\n        return 10; // Default: 5\n    }\n\n    get apiProxyTimeoutSec() {\n        return 30; // Default: 60\n    }\n\n    // This potentially blocks rendering, so it should be low\n    get microfrontendSSRTimeoutSec() {\n        return 3; // Default: 5\n    }\n}\n</code></pre>"},{"location":"implementation-hints/host-applications/#security","title":"Security","text":"<p>Multiple Microfrontend routes can declare security requirements:</p> <ul> <li>API proxies</li> <li>The SSR route</li> <li>The User Permissions route (it is very likely to do so)</li> </ul> <p>In this case you need to provide the necessary security headers:</p> <pre><code>export default class MyMicrofrontendBaseSetupImpl implements MyMicrofrontendBaseSetup {\n\n    async apiProxyRequestCustomerApiSecurityHeaders(req: IncomingMessage) {\n        return {\n            'x-api-key': '123456',\n        };\n    }\n\n    async ssrGetSecurityHeaders(req: IncomingMessage) {\n        return {\n            'x-api-key': '123456',\n        };\n    }\n\n    async userPermissionsRequestGetSecurityHeaders(req: IncomingMessage) {\n        return {\n            'x-api-key': '123456',\n        };\n    }\n}\n</code></pre>"},{"location":"implementation-hints/host-applications/#caching","title":"Caching","text":"<p>The generated integration code allows you to cache the following:</p> <ul> <li>BuildManifest version or timestamp</li> <li>User Permissions</li> <li>SSR result</li> </ul> <p>Tip</p> <p>You should at least cache the BuildManifest result for a couple of minutes, otherwise there will be a request to the Microfrontend Server every time the Microfrontend is started.</p> <pre><code>export default class MyMicrofrontendBaseSetupImpl implements MyMicrofrontendBaseSetup {\n\n    async buildTimestampOrVersionCachePut(tsOrVersion: string) {\n        // TODO\n    }\n\n    async buildTimestampOrVersionCacheGet() {\n        // TODO\n        return null;\n    }\n\n    // Be careful here, the SSR result may depend on the current user\n    async ssrCachePut(key: string, userName: string | undefined, result: object) {\n        // TODO\n    }\n\n    async ssrCacheGet(key: string, userName: string | undefined) {\n        // TODO\n        return null;\n    }\n\n    // Only use this if calculating the permissions is expensive\n    async userPermissionsCachePut(key: string, userPermissions: object) {\n        // TODO\n    }\n\n    async userPermissionsCacheGet(key: string) {\n        // TODO\n        return null;\n    }\n}\n</code></pre>"},{"location":"implementation-hints/host-applications/#custom-host-application-integration","title":"Custom Host Application Integration","text":"<p>If you plan to implement a custom Host Application integration, or want to add OpenMicrofrontends support to your existing Portal, you should:</p> <ol> <li>Read the Spec (most important!)</li> <li>Check out how the OpenMicrofrontends Generator works </li> <li>Consider the hints below</li> </ol>"},{"location":"implementation-hints/host-applications/#starter","title":"Starter","text":"<p>A Starter needs to do the following:</p> <ul> <li>Load all assets in the Description</li> <li>Determine the Renderer function</li> <li>Determine the required context (as defined here)</li> <li>Call the Renderer with the host element and the context</li> </ul>"},{"location":"implementation-hints/host-applications/#loading-js","title":"Loading JS","text":"<p>All JS assets must be loaded in the sequence defined in the Description:</p> <ul> <li>By adding a script tag to the HTML head (if no modulesSystem defined or none)</li> <li>By importing it with import() or System.import() (depending on the moduleSystem)</li> </ul>"},{"location":"implementation-hints/host-applications/#loading-css","title":"Loading CSS","text":"<p>The CSS assets should just be added via link tag to the HTML head (in any order).</p>"},{"location":"implementation-hints/host-applications/#determine-the-renderer-function","title":"Determine the Renderer function","text":"<p>Here an example implementation:</p> <pre><code>const rendererFunctionName = 'myStarter';\nconst exportedModules = []; // Empty if no moduleSystem\n\nconst rendererFunction =\n    exportedModules.find((m) =&gt; rendererFunctionName in m)?.[rendererFunctionName] ||\n    exportedModules.find((m) =&gt; 'default' in m &amp;&amp; rendererFunctionName in m.default)?.default?.[rendererFunctionName] ||\n    (window as any)[rendererFunctionName];\n</code></pre>"},{"location":"implementation-hints/host-applications/#modules-and-importmap","title":"Modules and importMap","text":"<p>If Microfrontends define an importMap you have to:</p> <ul> <li>Add it to the HTML page</li> <li>Resolve conflicts if Microfrontends define the same module name with a different target URL</li> </ul> <p>In case of ESM, because the limitations mentioned here, you have to calculate a static importMap  and add it to the page before you start the first Microfrontend. </p> <p>With SystemJS you can add new importMaps dynamically, even after other modules have been loaded.</p> <p>An algorithm to resolve module name conflicts might work like this:</p> <ul> <li>If a module is not in importMaps.imports add it there</li> <li>Otherwise, create a scope for every Microfrontend asset and add it there</li> <li>For every module added to a scope, create an additional scope and add all modules from the same importMap.    This makes sure that external modules import only modules defined in the same importMap</li> </ul> <p>Example:</p> Microfrontend 1 on mf1.foo.com<pre><code>importMap:\n  imports:\n    module1: 'https://my-modules.com/module1_1_0_0.js',\n    module2: 'https://my-modules.com/module2_1_0_0.js',\n</code></pre> Microfrontend 2 on mf2.foo.com<pre><code>importMap:\n  imports:\n    module1: 'https://my-modules.com/module1_1_2_0.js',\n    module2: 'https://my-modules.com/module2_1_2_0.js',\n</code></pre> <p>Would lead to this importMap:</p> <pre><code>{\n  \"imports\": {\n    \"module1\": \"https://my-modules.com/module1_1_0_0.js\",\n    \"module2\": \"https://my-modules.com/module2_1_0_0.js\"\n  },\n  \"scopes\": {\n    \"https://mf2.foo.com/public/Microfrontend.js\": {\n      \"module1\": \"https://my-modules.com/module1_1_2_0.js\",\n      \"module2\": \"https://my-modules.com/module2_1_2_0.js\"\n    },\n    \"https://my-modules.com/module1_1_2_0.js\": {\n      \"module2\": \"https://my-modules.com/module2_1_2_0.js\"\n    },\n    \"https://my-modules.com/module2_1_2_0.js\": {\n      \"module1\": \"https://my-modules.com/module1_1_2_0.js\",\n    }\n  }\n}\n</code></pre> <p>Note</p> <p>This algorithm is not perfect, but should work for most cases.</p>"},{"location":"implementation-hints/host-applications/#browser-caching","title":"Browser Caching","text":"<p>To make sure you get the correct asset version you should:</p> <ul> <li>Fetch from time to time the Build Manifest and append the version or timestamp property to every asset (?v=1.0.0)</li> <li>Alternatively, if there is no Build Manifest, add some query that changes every couple of minutes (at least)</li> </ul> <p>If moduleSystem is ESM or SystemJS you should also add an importMap entry for the full asset url (with query) so imports from other modules still work:</p> <pre><code>{\n  \"imports\": {\n    \"https://mf1.foo.com/public/Microfrontend.js\": \"https://mf1.foo.com/public/Microfrontend.js?v=1.0.0\"\n  }\n}\n</code></pre>"},{"location":"implementation-hints/host-applications/#host-backend","title":"Host Backend","text":"<p>Your custom Host Backend must provide the following:</p> <ul> <li>A route for the Microfrontend setup with all the context information the backend needs to provide:<ul> <li>User</li> <li>User Permissions</li> <li>Language</li> <li>Proxy Paths</li> <li>Host Context</li> </ul> </li> <li>A proxy for the assets (optional, but recommended)</li> <li>An API proxy</li> <li>Server-Side Rendering (optional)</li> </ul>"},{"location":"implementation-hints/host-applications/#asset-proxy","title":"Asset Proxy","text":"<p>The Asset Proxy should provide a route that forwards GET requests to the asset basePath of the Microfrontends.</p> <p>Example:</p> <p><code>&lt;host-application&gt;/microfrontends/microfrontend1/assets/index.js</code> \u2192 <code>https://my-microfrontend.com/public/index.js</code></p>"},{"location":"implementation-hints/host-applications/#api-proxies_1","title":"API Proxies","text":"<p>An API Proxy should provide a route that forwards everything to the API target URL. </p> <p>Example:</p> <p><code>&lt;host-application&gt;/microfrontends/microfrontend1/proxies/bff/customers/1234</code> \u2192 <code>https://my-microfrontend.com/api/customers/1234</code></p>"},{"location":"implementation-hints/host-applications/#caching_1","title":"Caching","text":"<p>There are several things you could cache in your backend:</p> <ul> <li>Build Manifests</li> <li>SSR results </li> <li>User Permissions </li> </ul> <p>At the very least, you should cache Build Manifests for a couple of minutes.</p>"},{"location":"implementation-hints/host-applications/#host-context","title":"Host Context","text":"<p>If you want to make the Microfrontends aware of some host specifics you can pass a context.hostContext object when calling the Renderer.</p>"},{"location":"implementation-hints/host-applications/#annotations","title":"Annotations","text":"<p>You might define specific annotations for your implementation which Microfrontends can, for example, use to control their appearance.</p>"},{"location":"implementation-hints/microfrontends/","title":"Microfrontend Implementation Hints","text":""},{"location":"implementation-hints/microfrontends/#exposing-microfrontendsyaml","title":"Exposing microfrontends.yaml","text":"<p>Although it is not mandatory, it is recommended to expose the Description file under</p> <ul> <li>/microfrontends.yaml</li> <li>or /microfrontends.json</li> </ul> <p>Because we expect Host Applications and tooling to appear, that will use this for automatic discovery of available Microfrontends.</p> <p>If you use external JSON schemas in your Description file, you should expose them as well.</p>"},{"location":"implementation-hints/microfrontends/#implementing-the-renderer","title":"Implementing the Renderer","text":"<p>You have to implement a Renderer that satisfies the signature defined here.</p> <p>OpenMicrofrontends Generator can create a typed version of the interface. </p> <p>Here for example an implementation for a Vue.js-based Microfrontend:</p> <pre><code>import {createApp} from 'vue';\nimport MyMicrofrontend from './MyMicrofrontend.vue';\nimport {MyMicrofrontendRenderer} from './_generated/microfrontendRenderers';\n\nconst renderer: MyMicrofrontendRenderer = async (host, context) =&gt; {\n    const {config, messageBus} = context;\n\n    const mf = createApp(MyMicrofrontend, {\n        welcomeMessage: config.welcomeMessage,\n    });\n    mf.mount(host);\n\n    return {\n        onRemove: () =&gt; {\n            mf.unmount();\n        }\n    }\n}\n</code></pre>"},{"location":"implementation-hints/microfrontends/#exporting-the-render-function","title":"Exporting the Render Function","text":"<p>There are multiple ways to export the Renderer. </p> <p>The generic way it to add it as global variable:</p> <pre><code>import {MyMicrofrontendRendererFunctionName} from './_generated/microfrontendRenderers';\n\n// ...\n\nwindow[MyMicrofrontendRendererFunctionName] = rendererFn;\n</code></pre> <p>If moduleSystem is ESM or SystemJS you can also export it:</p> <pre><code>import {MyMicrofrontendRendererFunctionName} from './_generated/microfrontendRenderers';\n\n// ...\n\n// Named export (must match renderFunctionName in the Description)\nexport const startMyMicrofrontend = rendererFn;\n\n// As property of the default export \n// (Recommended, because like this you can use the generated name constant):\nexport default {\n    [MyMicrofrontendRendererFunctionName]: rendererFn,\n};\n</code></pre>"},{"location":"implementation-hints/microfrontends/#bundling-assets","title":"Bundling Assets","text":"<p>You can use any bundler and tooling you want. But you should keep in mind that:</p> <ul> <li>The initial asset names must be stable, i.e., they must have a fixed name</li> <li>The output of your bundler must match the moduleSystem in the Description</li> <li>If your Microfrontend supports Server-Side Rendering you should create separate CSS files (so the initial HTML gets rendered properly)</li> </ul> <p>Example configurations for common bundlers:</p> webpack<pre><code>{\n    experiments: {\n        // outputModule: true, // ESM\n    },\n    output: {\n        path: resolve(import.meta.dirname, 'dist'),\n        filename: 'Microfrontend.js', // Stable\n        // module: true, // ESM\n        // libraryTarget: 'system', // SystemJS\n    },\n}\n</code></pre> Rollup<pre><code>{\n    output: [{\n        dir: 'dist',\n        entryFileNames: '[name].js', // Stable\n        // format: 'es', // ESM\n        // format: 'system', // SystemJS\n    }],\n}\n</code></pre> Vite<pre><code>{\n    build: {\n        rollupOptions: {\n            output: [{\n                dir: 'dist',\n                entryFileNames: '[name].js', // Stable\n                format: 'iife',\n                // format: 'es', // ESM\n                // format: 'system', // SystemJS\n            }],\n        }\n    }\n}\n</code></pre>"},{"location":"implementation-hints/microfrontends/#code-splitting","title":"Code Splitting","text":"<p>If you want to use dynamic <code>import()</code> or other code-splitting measures there are more things to consider:</p> <ul> <li>All references to modules/chunks must be relative because the Host Applications may change the base path of the assets.    This means, the public path must be determined from the initial assets.</li> <li>All assets not listed in the Descriptions should have a hash in their name for cache busting</li> </ul> <p>Add the following to your bundler configuration:</p> webpack<pre><code>{\n    output: {\n        // ...\n        publicPath: 'auto', // automatic public path, can just be omitted   \n        chunkFilename: 'chunk.[contenthash].js',\n    },\n}\n</code></pre> Rollup<pre><code>{\n    output: [{\n        // ...\n        assetFileNames: '[name]-[hash][extname]',\n        chunkFileNames: '[name]-[hash].js',\n    }],\n}\n</code></pre> Vite<pre><code>{\n    base: '', // automatic public path   \n    build: {\n        rollupOptions: {\n            // ...\n            output: [{\n                assetFileNames: '[name]-[hash][extname]',\n                chunkFileNames: '[name]-[hash].js',\n            }],\n        }\n    }\n}\n</code></pre> <p>Here you can find a working example.</p> <p>Warning</p> <p>If you use code splitting with ESM, check out the limitations below.</p>"},{"location":"implementation-hints/microfrontends/#shared-libraries","title":"Shared Libraries","text":"<p>The recommended way to share libraries and to reduce the bundle size are importMaps. </p> <p>Keep in mind that:</p> <ul> <li>For every external you define in your bundler configuration, there needs to be an entry in your importMap</li> <li>Sometimes external modules import additional modules, they need to be in the importMap as well</li> <li>The moduleSystem must be ESM or SystemJS</li> <li>The modules listed in the importMap must match the moduleSystem </li> </ul> <p>Here possible bundler configurations for a React Microfrontend that uses SystemJS as moduleSystem:</p> webpack<pre><code>{\n    output: {\n        path: resolve(import.meta.dirname, 'dist'),\n        filename: 'Microfrontend1.js',\n        libraryTarget: 'system',\n    },\n    externalsType: 'system',\n    externals: {\n        'react': 'react',\n        'react-dom': 'react-dom',\n        'react-dom/client': 'react-dom/client',\n    },\n}\n</code></pre> Rollup<pre><code>{\n    output: {\n        dir: 'dist',\n            entryFileNames: '[name].js',\n            format: 'system',\n    },\n    external: ['react', 'react-dom', 'react-dom/client'],\n}\n</code></pre> Vite<pre><code>{\n    base: '', // automatic public path   \n    build: {\n        rollupOptions: {\n            // ...\n            output: {\n                dir: 'dist',\n                entryFileNames: '[name].js',\n                format: 'system',\n            },\n            external: ['react', 'react-dom', 'react-dom/client'],\n        }\n    }\n}\n</code></pre> <p>The matching importMap declaration would be:</p> <pre><code>importMap:\n    imports:\n      react: https://ga.system.jspm.io/npm:react@19.1.1/index.js\n      react-dom: https://ga.system.jspm.io/npm:react-dom@19.1.1/index.js\n      react-dom/client: https://ga.system.jspm.io/npm:react-dom@19.1.1/client.js\n      scheduler: https://ga.system.jspm.io/npm:scheduler@0.26.0/index.js\n      process: https://ga.system.jspm.io/npm:process@0.11.10/browser.js\n</code></pre> <p>And you should use the exact same importMap during development in your test page:</p> <pre><code>&lt;script type=\"systemjs-importmap\"&gt;\n{\n  \"imports\": {\n    \"react\": \"https://ga.system.jspm.io/npm:react@19.1.1/index.js\",\n    \"react-dom\": \"https://ga.system.jspm.io/npm:react-dom@19.1.1/index.js\",\n    \"react-dom/client\": \"https://ga.system.jspm.io/npm:react-dom@19.1.1/client.js\",\n    \"scheduler\": \"https://ga.system.jspm.io/npm:scheduler@0.26.0/index.js\",\n    \"process\": \"https://ga.system.jspm.io/npm:process@0.11.10/browser.js\"\n  }\n}\n&lt;/script&gt;\n</code></pre> <p>Here you can find a working example.</p> <p>Warning</p> <p>Although, importMaps are supported for moduleSystem ESM and SystemJS, keep in mind that ESM has some serious limitations, see below.</p>"},{"location":"implementation-hints/microfrontends/#esm-limitations","title":"ESM Limitations","text":"<p>There are serious limitations to ES modules because some browsers still only support a single importMap which needs to be preset before the first  ES module is loaded, see this issue.</p> <p>This means, Host Applications would have to merge all importMaps into a single one and add it to the HTML page before the first Microfrontend starts. </p> <p>This leads to the following limitations with ESM when using OpenMicrofrontends Generator, because it generates Starters which load Microfrontend dynamically:</p> <ul> <li>importMaps are not supported at all (generation will fail)</li> <li>Code splitting only works if the entry file dynamically imports all dependencies, including the framework and components.    Without this, using query parameters for cache busting (e.g., <code>Microfrontend.js?v=123</code>) would break the module resolution.</li> </ul>"},{"location":"implementation-hints/microfrontends/#asset-caching","title":"Asset Caching","text":"<p>Here some best practices regarding caching:</p> <ul> <li>The Cache-Control header for your assets should be set to a max-age of multiple days, to make sure the browsers and the proxies in between cache it and reduce the load on your server</li> <li>At the same time you should set the buildManifest to give the Host Application means for cache busting if a new version of the Microfrontend gets deployed</li> </ul>"},{"location":"implementation-hints/microfrontends/#styling","title":"Styling","text":"<p>Styling Microfrontends is a notorious challenging topic, because:</p> <ul> <li>It should be possible to align the Look&amp;Feel to the Host Application</li> <li>You don't want to affect elements outside the Microfrontend on the same page </li> <li>You don't want to load the same CSS rules over and over again (in multiple Microfrontends)</li> </ul> <p>So, if you can avoid it, you should not bring any CSS rules at all but use CSS classes from a design system provided by the Host Application. Here, an example with Tailwind CSS:</p> Host Application<pre><code>html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4\"&gt;&lt;/script&gt;\n    &lt;style type=\"text/tailwindcss\"&gt;\n        @theme {\n          --color-clifford: #da373d;\n        }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"microfrontend-root\"&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Microfrontend<pre><code>export default function MyMicrofrontend() {\n    return (\n        &lt;div className=\"text-gray-700 dark:text-gray-400\"&gt;\n            Hello World!\n        &lt;/div&gt;    \n    )\n};\n</code></pre> If you really need to bring your own CSS rules, make sure to:</p> <ul> <li>Provide CSS variables to align the style with the Host Application</li> <li>Use a unique prefix for all your selectors to avoid conflicts and unwanted side effects. For example, you could use this postcss plugin.</li> </ul>"},{"location":"implementation-hints/microfrontends/#internationalization","title":"Internationalization","text":"<p>The Host Application may pass the current language as part of the context:</p> <pre><code>const renderer: MyMicrofrontendRenderer = async (host, context) =&gt; {\n    const {config, lang} = context;\n\n    // Use lang (e.g., \"fr\") to dynamically select the correct message bundle\n}\n</code></pre>"},{"location":"implementation-hints/microfrontends/#user-information","title":"User Information","text":"<p>The Host Application may pass some basic user information:</p> <pre><code>const renderer: MyMicrofrontendRenderer = async (host, context) =&gt; {\n    const {config, user} = context;\n\n    const displayName =  user?.displayName ?? 'Anonymous';\n}\n</code></pre>"},{"location":"implementation-hints/microfrontends/#browser-routing","title":"Browser Routing","text":"<p>The OpenMicrofrontends specification does not directly allow to describe routes, because that's something the Host Application needs to take care of. </p> <p>If you Microfrontend uses routes (or in any other way manipulates the location) take into consideration:</p> <ul> <li>This significantly reduces the versatility of your Microfrontend, because it cannot be combined with other Microfrontends that do the same on a Host Application page</li> <li>You should provide a way to configure the route prefix to the Host Application</li> <li>It might be a good idea to add some annotation with a hint that the Microfrontend is manipulating the location</li> </ul> <p>An example for a configurable route prefix and an annotation:</p> <pre><code># ...\nconfig:\n  schema:\n    type: object\n    properties:\n      routePrefix:\n        type: string\n        description: A route prefix, e.g., /microfrontend1\n    required:\n      - routePrefix\n    additionalProperties: false\n  default:\n    routePrefix: ''\nannotations:\n  MANIPULATES_LOCATION: true\n</code></pre> <p>Here you can find a working example.</p>"},{"location":"implementation-hints/microfrontends/#server-side-rendering","title":"Server-Side Rendering","text":"<p>To enable SSR routing for your Microfrontend you have to add two things:</p> <ol> <li>A server route that delivers the initial HTML </li> <li>The capability to hydrate the frontend in your client-side Renderer</li> </ol> <p>The SSR route takes a POST request and passes the body to the server-side Renderer function defined here.</p> <p>OpenMicrofrontends Generator can create a typed version of the interface.</p> <p>Here for a Vue.js-based Microfrontend on an Express-based server:</p> <pre><code>import { createSSRApp } from 'vue';\nimport { renderToString } from 'vue/server-renderer';\nimport type {MyMicrofrontendServerSideRenderer} from \"../_generated/microfrontendRenderersServerSide\";\n\nconst rendererFn: MyMicrofrontendServerSideRenderer = async (requestBody) =&gt; {\n    const {config} = requestBody;\n\n    const microfrontend = createSSRApp(Microfrontend, {\n        welcomeMessage: config.welcomeMessage,\n    });\n\n    const html = await renderToString(microfrontend);\n\n    return {\n        html,\n        // injectHeadScript,\n    };\n};\n\nconst app = express();\napp.use(express.json());\n\napp.post('/ssr', async (req, res) =&gt; {\n    const result = await rendererFn(req.body);\n    res.json(response);\n});\n</code></pre> <p>Tip</p> <p>The injectHeadScript property can be used to inject some preloaded state for the hydration</p> <p>In the client-side Renderer you can use the serverSideRendered flag to determine if hydration should be performed:</p> <pre><code>import {createApp} from 'vue';\nimport MyMicrofrontend from './MyMicrofrontend.vue';\nimport {MyMicrofrontendRenderer} from './_generated/microfrontendRenderers';\n\nconst renderer: MyMicrofrontendRenderer = async (host, context) =&gt; {\n    const {config, serverSideRendered} = context;\n\n    if (serverSideRendered) {\n        // Hydrate\n        // ...\n    } else {\n        // Render\n        // ...\n    }\n\n    // ...\n}\n</code></pre> <p>The corresponding Description would look like this:</p> <pre><code>  # ...\n  ssr:\n    path: /ssr\n</code></pre> <p>Here you can find a working example.</p>"}]}